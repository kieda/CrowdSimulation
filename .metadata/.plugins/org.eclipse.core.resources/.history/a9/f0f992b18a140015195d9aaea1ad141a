package edu.cmu.cs464.p3.modulelang.linker

import edu.cmu.cs464.p3.modulelang.ast.Program
import edu.cmu.cs464.p3.modulelang.ast.Node
import edu.cmu.cs464.p3.modulelang.ast.ModuleImport
import edu.cmu.cs464.p3.modulelang.ast.ParsedModule
import edu.cmu.cs464.p3.modulelang.ast.JavaRef

/**
 * @author zkieda
 */
class Linker
object Linker {
  {
    try {
      
    } catch {
      case t: Throwable => t.printStackTrace() // TODO: handle error
    }
  }
  
  private def tryGetClass (handle : ClassNotFoundException => Class[_]) (s : String) = 
    try{
      Class.forName(s, false, getClass().getClassLoader) 
    } catch {
      case e : ClassNotFoundException => handle(e) 
    } 
      
  private def genImports(L : List[ModuleImport]) : (JavaRef => Class[_]) = 
    L.foldLeft ((j : JavaRef) => tryGetClass (e => 
      throw new LinkingException("Java reference " + j + " not found.", e)) (j.toString())
      ) ((f, moduleImport) =>
        j => 
          if(moduleImport.isPackageImport && j.isSingle) tryGetClass(handle)(s)
          else if(moduleImport.refEquals(j)) tryGetClass (_ => f(j)) (j.toString())
          else f(j)
      );
//    {
//    if (L.isEmpty) ???
//    else {
//      val x = L.last
//      val R = L.drop(1)
//      genImports(R)
//    }
//  }
  
  private def construct (f : JavaRef => Class[_]) (n : Node) : ClassTree = n match {
    
    case ParsedModule(baseClass, children) => 
      var L : List[ClassTree] = List()
      for(i <- (0 until children.size())) {
        L = construct (f) (children.get(i))::L 
      }
      ClassTree(f(baseClass), L)
      
      //never visited
//    case Program(imports, module) => ???
//    case ModuleImport(path) => ???
//    case JavaRef(path) => ???
  }
  private def baseFn (j : JavaRef) : Class[_] = throw new LinkingException("Java reference " + j + " not found in context");
  
  def link(p : Program) = p match {
    case Program(imports, module) => 
      var L : List[ModuleImport] = List()
      for(i <- (0 until imports.size())) {
        L = imports.get(i)::L 
      }
      construct (genImports(L)) (module)
  }
}